#!/usr/bin/env node

/**
 * T002: Utility Functions Setup Script (Simple Version)
 * 
 * Direct Node.js script to create utility functions for remote installation system.
 */

const fs = require('fs');
const path = require('path');

class UtilityFunctionsSetup {
  constructor(projectRoot = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  async setupUtilityFunctions() {
    try {
      console.log('🚀 Starting utility functions setup (T002)...');
      
      // Create utility files
      await this.createCommonUtilities();
      await this.createLoggerUtilities();
      await this.createErrorHandlerUtilities();
      await this.createColorUtilities();
      await this.createFilesystemUtilities();
      
      console.log('✅ Utility functions setup completed successfully');
      console.log('📄 Created utility files:');
      console.log('   - scripts/utils/common.sh');
      console.log('   - scripts/utils/logger.sh');
      console.log('   - scripts/utils/error-handler.sh');
      console.log('   - scripts/utils/colors.sh');
      console.log('   - scripts/utils/filesystem.sh');
      console.log('');
      console.log('🔧 All utility files have executable permissions');
      console.log('📚 Utility functions include:');
      console.log('   - Logging utilities (log_info, log_error, log_warn, log_debug)');
      console.log('   - Error handling with trap and cleanup');
      console.log('   - Colored output for better UX');
      console.log('   - File system operations with proper error handling');
      console.log('   - Input validation and sanitization functions');
      
    } catch (error) {
      console.error('❌ Failed to setup utility functions:', error);
      throw error;
    }
  }

  async createCommonUtilities() {
    const utilsDir = path.join(this.projectRoot, 'scripts/utils');
    const commonFile = path.join(utilsDir, 'common.sh');
    
    const content = [
      '#!/bin/bash',
      '# Common utility functions',
      '# Generated by UtilityFunctionsSetup',
      '',
      'set -euo pipefail',
      '',
      '# Get the directory of the current script',
      'get_script_dir() {',
      '    echo "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"',
      '}',
      '',
      '# Validate input parameters',
      'validate_input() {',
      '    local input="$1"',
      '    local description="$2"',
      '    ',
      '    if [[ -z "$input" ]]; then',
      '        log_error "Invalid input: $description cannot be empty"',
      '        return 1',
      '    fi',
      '    ',
      '    # Check for dangerous characters',
      '    if [[ "$input" =~ [;&|`$] ]]; then',
      '        log_error "Invalid input: $description contains dangerous characters"',
      '        return 1',
      '    fi',
      '    ',
      '    return 0',
      '}',
      '',
      '# Sanitize file path',
      'sanitize_path() {',
      '    local path="$1"',
      '    ',
      '    # Remove dangerous characters and normalize path',
      '    path=$(echo "$path" | sed "s/[;&|`$]//g")',
      '    path=$(realpath "$path" 2>/dev/null || echo "$path")',
      '    ',
      '    echo "$path"',
      '}',
      '',
      '# Check if required dependencies are available',
      'check_dependencies() {',
      '    local deps=("$@")',
      '    local missing=()',
      '    ',
      '    for dep in "${deps[@]}"; do',
      '        if ! command -v "$dep" &> /dev/null; then',
      '            missing+=("$dep")',
      '        fi',
      '    done',
      '    ',
      '    if [[ ${#missing[@]} -gt 0 ]]; then',
      '        log_error "Missing dependencies: ${missing[*]}"',
      '        return 1',
      '    fi',
      '    ',
      '    return 0',
      '}',
      '',
      '# Check if running as root',
      'check_root() {',
      '    if [[ $EUID -eq 0 ]]; then',
      '        log_warn "Running as root. This may cause permission issues."',
      '        return 0',
      '    fi',
      '    return 1',
      '}',
      '',
      '# Get system information',
      'get_system_info() {',
      '    local os=$(uname -s)',
      '    local arch=$(uname -m)',
      '    local hostname=$(hostname)',
      '    ',
      '    echo "OS: $os"',
      '    echo "Architecture: $arch"',
      '    echo "Hostname: $hostname"',
      '}',
      '',
      '# Create temporary directory',
      'create_temp_dir() {',
      '    local temp_dir=$(mktemp -d)',
      '    echo "$temp_dir"',
      '}',
      '',
      '# Cleanup temporary directory',
      'cleanup_temp_dir() {',
      '    local temp_dir="$1"',
      '    if [[ -d "$temp_dir" ]]; then',
      '        rm -rf "$temp_dir"',
      '    fi',
      '}',
      '',
      'echo "Common utilities loaded successfully"'
    ].join('\n');

    await this.createShellScript(commonFile, content);
  }

  async createLoggerUtilities() {
    const utilsDir = path.join(this.projectRoot, 'scripts/utils');
    const loggerFile = path.join(utilsDir, 'logger.sh');
    
    const content = [
      '#!/bin/bash',
      '# Logging utilities',
      '# Generated by UtilityFunctionsSetup',
      '',
      'set -euo pipefail',
      '',
      '# Source common utilities',
      'SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"',
      'if [[ -f "${SCRIPT_DIR}/common.sh" ]]; then',
      '    source "${SCRIPT_DIR}/common.sh"',
      'fi',
      '',
      '# Log levels',
      'LOG_LEVEL_ERROR=1',
      'LOG_LEVEL_WARN=2',
      'LOG_LEVEL_INFO=3',
      'LOG_LEVEL_DEBUG=4',
      '',
      '# Default log level',
      'LOG_LEVEL=${LOG_LEVEL:-$LOG_LEVEL_INFO}',
      '',
      '# Get timestamp',
      'get_timestamp() {',
      '    date "+%Y-%m-%d %H:%M:%S"',
      '}',
      '',
      '# Log info message',
      'log_info() {',
      '    if [[ $LOG_LEVEL -ge $LOG_LEVEL_INFO ]]; then',
      '        echo -e "$(get_timestamp) [INFO] $*" >&2',
      '    fi',
      '}',
      '',
      '# Log error message',
      'log_error() {',
      '    if [[ $LOG_LEVEL -ge $LOG_LEVEL_ERROR ]]; then',
      '        echo -e "$(get_timestamp) [ERROR] $*" >&2',
      '    fi',
      '}',
      '',
      '# Log warning message',
      'log_warn() {',
      '    if [[ $LOG_LEVEL -ge $LOG_LEVEL_WARN ]]; then',
      '        echo -e "$(get_timestamp) [WARN] $*" >&2',
      '    fi',
      '}',
      '',
      '# Log debug message',
      'log_debug() {',
      '    if [[ $LOG_LEVEL -ge $LOG_LEVEL_DEBUG ]]; then',
      '        echo -e "$(get_timestamp) [DEBUG] $*" >&2',
      '    fi',
      '}',
      '',
      '# Set log level',
      'set_log_level() {',
      '    case "$1" in',
      '        "error") LOG_LEVEL=$LOG_LEVEL_ERROR ;;',
      '        "warn") LOG_LEVEL=$LOG_LEVEL_WARN ;;',
      '        "info") LOG_LEVEL=$LOG_LEVEL_INFO ;;',
      '        "debug") LOG_LEVEL=$LOG_LEVEL_DEBUG ;;',
      '        *) log_error "Invalid log level: $1" ; return 1 ;;',
      '    esac',
      '}',
      '',
      'echo "Logger utilities loaded successfully"'
    ].join('\n');

    await this.createShellScript(loggerFile, content);
  }

  async createErrorHandlerUtilities() {
    const utilsDir = path.join(this.projectRoot, 'scripts/utils');
    const errorHandlerFile = path.join(utilsDir, 'error-handler.sh');
    
    const content = [
      '#!/bin/bash',
      '# Error handling utilities',
      '# Generated by UtilityFunctionsSetup',
      '',
      'set -euo pipefail',
      '',
      '# Source common utilities',
      'SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"',
      'if [[ -f "${SCRIPT_DIR}/common.sh" ]]; then',
      '    source "${SCRIPT_DIR}/common.sh"',
      'fi',
      '',
      '# Global variables for cleanup',
      'CLEANUP_FUNCTIONS=()',
      'TEMP_DIRS=()',
      'BACKUP_FILES=()',
      '',
      '# Add cleanup function',
      'add_cleanup_function() {',
      '    CLEANUP_FUNCTIONS+=("$1")',
      '}',
      '',
      '# Add temporary directory for cleanup',
      'add_temp_dir() {',
      '    TEMP_DIRS+=("$1")',
      '}',
      '',
      '# Add backup file for cleanup',
      'add_backup_file() {',
      '    BACKUP_FILES+=("$1")',
      '}',
      '',
      '# Cleanup function',
      'cleanup() {',
      '    log_info "Cleaning up..."',
      '    ',
      '    # Run cleanup functions',
      '    for func in "${CLEANUP_FUNCTIONS[@]}"; do',
      '        if declare -f "$func" > /dev/null; then',
      '            log_debug "Running cleanup function: $func"',
      '            "$func" || true',
      '        fi',
      '    done',
      '    ',
      '    # Remove temporary directories',
      '    for temp_dir in "${TEMP_DIRS[@]}"; do',
      '        if [[ -d "$temp_dir" ]]; then',
      '            log_debug "Removing temporary directory: $temp_dir"',
      '            rm -rf "$temp_dir" || true',
      '        fi',
      '    done',
      '    ',
      '    # Restore backup files',
      '    for backup_file in "${BACKUP_FILES[@]}"; do',
      '        if [[ -f "$backup_file" ]]; then',
      '            log_debug "Restoring backup file: $backup_file"',
      '            mv "$backup_file" "${backup_file%.backup}" || true',
      '        fi',
      '    done',
      '}',
      '',
      '# Error handler',
      'handle_error() {',
      '    local exit_code=$?',
      '    local line_number=$1',
      '    ',
      '    log_error "Error occurred on line $line_number with exit code $exit_code"',
      '    cleanup',
      '    exit $exit_code',
      '}',
      '',
      '# Rollback function',
      'rollback() {',
      '    log_warn "Rolling back changes..."',
      '    cleanup',
      '    exit 1',
      '}',
      '',
      '# Set up error handling',
      'setup_error_handling() {',
      '    # Trap errors',
      '    trap "handle_error $LINENO" ERR',
      '    ',
      '    # Trap exit',
      '    trap "cleanup" EXIT',
      '    ',
      '    # Trap interrupt',
      '    trap "log_warn \"Interrupted by user\"; rollback" INT TERM',
      '}',
      '',
      '# Check if command exists',
      'command_exists() {',
      '    command -v "$1" >/dev/null 2>&1',
      '}',
      '',
      '# Run command with error handling',
      'run_command() {',
      '    local cmd="$*"',
      '    log_debug "Running command: $cmd"',
      '    ',
      '    if eval "$cmd"; then',
      '        log_debug "Command succeeded: $cmd"',
      '        return 0',
      '    else',
      '        log_error "Command failed: $cmd"',
      '        return 1',
      '    fi',
      '}',
      '',
      'echo "Error handler utilities loaded successfully"'
    ].join('\n');

    await this.createShellScript(errorHandlerFile, content);
  }

  async createColorUtilities() {
    const utilsDir = path.join(this.projectRoot, 'scripts/utils');
    const colorsFile = path.join(utilsDir, 'colors.sh');
    
    const content = [
      '#!/bin/bash',
      '# Color and formatting utilities',
      '# Generated by UtilityFunctionsSetup',
      '',
      'set -euo pipefail',
      '',
      '# Check if colors are supported',
      'if [[ -t 1 ]] && command -v tput >/dev/null 2>&1; then',
      '    # Colors are supported',
      '    RED="\\033[0;31m"',
      '    GREEN="\\033[0;32m"',
      '    YELLOW="\\033[1;33m"',
      '    BLUE="\\033[0;34m"',
      '    PURPLE="\\033[0;35m"',
      '    CYAN="\\033[0;36m"',
      '    WHITE="\\033[1;37m"',
      '    BOLD="\\033[1m"',
      '    DIM="\\033[2m"',
      '    NC="\\033[0m" # No Color',
      'else',
      '    # Colors are not supported',
      '    RED=""',
      '    GREEN=""',
      '    YELLOW=""',
      '    BLUE=""',
      '    PURPLE=""',
      '    CYAN=""',
      '    WHITE=""',
      '    BOLD=""',
      '    DIM=""',
      '    NC=""',
      'fi',
      '',
      '# Print colored text',
      'print_red() {',
      '    echo -e "${RED}$*${NC}"',
      '}',
      '',
      'print_green() {',
      '    echo -e "${GREEN}$*${NC}"',
      '}',
      '',
      'print_yellow() {',
      '    echo -e "${YELLOW}$*${NC}"',
      '}',
      '',
      'print_blue() {',
      '    echo -e "${BLUE}$*${NC}"',
      '}',
      '',
      'print_purple() {',
      '    echo -e "${PURPLE}$*${NC}"',
      '}',
      '',
      'print_cyan() {',
      '    echo -e "${CYAN}$*${NC}"',
      '}',
      '',
      'print_white() {',
      '    echo -e "${WHITE}$*${NC}"',
      '}',
      '',
      'print_bold() {',
      '    echo -e "${BOLD}$*${NC}"',
      '}',
      '',
      'print_dim() {',
      '    echo -e "${DIM}$*${NC}"',
      '}',
      '',
      '# Print success message',
      'print_success() {',
      '    print_green "✅ $*"',
      '}',
      '',
      '# Print error message',
      'print_error() {',
      '    print_red "❌ $*"',
      '}',
      '',
      '# Print warning message',
      'print_warning() {',
      '    print_yellow "⚠️  $*"',
      '}',
      '',
      '# Print info message',
      'print_info() {',
      '    print_blue "ℹ️  $*"',
      '}',
      '',
      '# Print header',
      'print_header() {',
      '    echo',
      '    print_bold "${BLUE}=== $* ===${NC}"',
      '    echo',
      '}',
      '',
      '# Print separator',
      'print_separator() {',
      '    echo -e "${DIM}$(printf "=%.0s" {1..80})${NC}"',
      '}',
      '',
      'echo "Color utilities loaded successfully"'
    ].join('\n');

    await this.createShellScript(colorsFile, content);
  }

  async createFilesystemUtilities() {
    const utilsDir = path.join(this.projectRoot, 'scripts/utils');
    const filesystemFile = path.join(utilsDir, 'filesystem.sh');
    
    const content = [
      '#!/bin/bash',
      '# File system utilities',
      '# Generated by UtilityFunctionsSetup',
      '',
      'set -euo pipefail',
      '',
      '# Source common utilities',
      'SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"',
      'if [[ -f "${SCRIPT_DIR}/common.sh" ]]; then',
      '    source "${SCRIPT_DIR}/common.sh"',
      'fi',
      '',
      '# Ensure directory exists',
      'ensure_directory_exists() {',
      '    local dir="$1"',
      '    ',
      '    if [[ ! -d "$dir" ]]; then',
      '        log_info "Creating directory: $dir"',
      '        mkdir -p "$dir"',
      '    fi',
      '}',
      '',
      '# Create file with content',
      'create_file_with_content() {',
      '    local file="$1"',
      '    local content="$2"',
      '    local dir',
      '    ',
      '    dir=$(dirname "$file")',
      '    ensure_directory_exists "$dir"',
      '    ',
      '    log_debug "Creating file: $file"',
      '    echo "$content" > "$file"',
      '}',
      '',
      '# Backup file',
      'backup_file() {',
      '    local file="$1"',
      '    local backup_file="${file}.backup.$(date +%Y%m%d_%H%M%S)"',
      '    ',
      '    if [[ -f "$file" ]]; then',
      '        log_info "Backing up file: $file -> $backup_file"',
      '        cp "$file" "$backup_file"',
      '        echo "$backup_file"',
      '    else',
      '        log_warn "File does not exist for backup: $file"',
      '        return 1',
      '    fi',
      '}',
      '',
      '# Validate path',
      'validate_path() {',
      '    local path="$1"',
      '    ',
      '    # Check if path is absolute',
      '    if [[ "$path" != /* ]]; then',
      '        log_error "Path must be absolute: $path"',
      '        return 1',
      '    fi',
      '    ',
      '    # Check for dangerous characters',
      '    if [[ "$path" =~ [;&|`$] ]]; then',
      '        log_error "Path contains dangerous characters: $path"',
      '        return 1',
      '    fi',
      '    ',
      '    return 0',
      '}',
      '',
      '# Safe remove',
      'safe_remove() {',
      '    local path="$1"',
      '    local force="${2:-false}"',
      '    ',
      '    if [[ ! -e "$path" ]]; then',
      '        log_warn "Path does not exist: $path"',
      '        return 0',
      '    fi',
      '    ',
      '    if [[ "$force" == "true" ]]; then',
      '        log_info "Force removing: $path"',
      '        rm -rf "$path"',
      '    else',
      '        log_info "Removing: $path"',
      '        rm -r "$path"',
      '    fi',
      '}',
      '',
      '# Get file size',
      'get_file_size() {',
      '    local file="$1"',
      '    ',
      '    if [[ -f "$file" ]]; then',
      '        stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0"',
      '    else',
      '        echo "0"',
      '    fi',
      '}',
      '',
      '# Get directory size',
      'get_directory_size() {',
      '    local dir="$1"',
      '    ',
      '    if [[ -d "$dir" ]]; then',
      '        du -sh "$dir" 2>/dev/null | cut -f1 || echo "0"',
      '    else',
      '        echo "0"',
      '    fi',
      '}',
      '',
      '# Check if file is executable',
      'is_executable() {',
      '    local file="$1"',
      '    ',
      '    if [[ -f "$file" && -x "$file" ]]; then',
      '        return 0',
      '    else',
      '        return 1',
      '    fi',
      '}',
      '',
      '# Make file executable',
      'make_executable() {',
      '    local file="$1"',
      '    ',
      '    if [[ -f "$file" ]]; then',
      '        chmod +x "$file"',
      '        log_debug "Made file executable: $file"',
      '    else',
      '        log_error "File does not exist: $file"',
      '        return 1',
      '    fi',
      '}',
      '',
      '# Copy file with permissions',
      'copy_file_with_permissions() {',
      '    local source="$1"',
      '    local destination="$2"',
      '    ',
      '    if [[ -f "$source" ]]; then',
      '        cp -p "$source" "$destination"',
      '        log_debug "Copied file with permissions: $source -> $destination"',
      '    else',
      '        log_error "Source file does not exist: $source"',
      '        return 1',
      '    fi',
      '}',
      '',
      '# Create symlink',
      'create_symlink() {',
      '    local target="$1"',
      '    local link="$2"',
      '    local force="${3:-false}"',
      '    ',
      '    if [[ -L "$link" ]]; then',
      '        if [[ "$force" == "true" ]]; then',
      '            rm "$link"',
      '        else',
      '            log_error "Symlink already exists: $link"',
      '            return 1',
      '        fi',
      '    fi',
      '    ',
      '    ln -s "$target" "$link"',
      '    log_debug "Created symlink: $link -> $target"',
      '}',
      '',
      '# Find files',
      'find_files() {',
      '    local pattern="$1"',
      '    local directory="${2:-.}"',
      '    ',
      '    find "$directory" -name "$pattern" -type f 2>/dev/null || true',
      '}',
      '',
      '# Find directories',
      'find_directories() {',
      '    local pattern="$1"',
      '    local directory="${2:-.}"',
      '    ',
      '    find "$directory" -name "$pattern" -type d 2>/dev/null || true',
      '}',
      '',
      'echo "Filesystem utilities loaded successfully"'
    ].join('\n');

    await this.createShellScript(filesystemFile, content);
  }

  async createShellScript(filePath, content) {
    // Ensure directory exists
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(filePath, content, 'utf8');
    
    // Set executable permissions
    const stats = fs.statSync(filePath);
    fs.chmodSync(filePath, stats.mode | parseInt('111', 8));
  }
}

// Run the setup if this script is executed directly
if (require.main === module) {
  const setup = new UtilityFunctionsSetup();
  setup.setupUtilityFunctions()
    .then(() => {
      console.log('');
      console.log('Next steps:');
      console.log('   - Run T003-T007: Test implementations (can be done in parallel)');
      console.log('   - Run T008: System Detection Module');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Setup failed:', error);
      process.exit(1);
    });
}

module.exports = UtilityFunctionsSetup;
