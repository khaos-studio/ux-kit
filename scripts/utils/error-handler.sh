#!/bin/bash
# Error handling utilities
# Generated by UtilityFunctionsSetup

set -euo pipefail

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${SCRIPT_DIR}/common.sh" ]]; then
    source "${SCRIPT_DIR}/common.sh"
fi

# Global variables for cleanup
CLEANUP_FUNCTIONS=()
TEMP_DIRS=()
BACKUP_FILES=()

# Add cleanup function
add_cleanup_function() {
    CLEANUP_FUNCTIONS+=("$1")
}

# Add temporary directory for cleanup
add_temp_dir() {
    TEMP_DIRS+=("$1")
}

# Add backup file for cleanup
add_backup_file() {
    BACKUP_FILES+=("$1")
}

# Cleanup function
cleanup() {
    log_info "Cleaning up..."
    
    # Run cleanup functions
    for func in "${CLEANUP_FUNCTIONS[@]}"; do
        if declare -f "$func" > /dev/null; then
            log_debug "Running cleanup function: $func"
            "$func" || true
        fi
    done
    
    # Remove temporary directories
    for temp_dir in "${TEMP_DIRS[@]}"; do
        if [[ -d "$temp_dir" ]]; then
            log_debug "Removing temporary directory: $temp_dir"
            rm -rf "$temp_dir" || true
        fi
    done
    
    # Restore backup files
    for backup_file in "${BACKUP_FILES[@]}"; do
        if [[ -f "$backup_file" ]]; then
            log_debug "Restoring backup file: $backup_file"
            mv "$backup_file" "${backup_file%.backup}" || true
        fi
    done
}

# Error handler
handle_error() {
    local exit_code=$?
    local line_number=$1
    
    log_error "Error occurred on line $line_number with exit code $exit_code"
    cleanup
    exit $exit_code
}

# Rollback function
rollback() {
    log_warn "Rolling back changes..."
    cleanup
    exit 1
}

# Set up error handling
setup_error_handling() {
    # Trap errors
    trap "handle_error $LINENO" ERR
    
    # Trap exit
    trap "cleanup" EXIT
    
    # Trap interrupt
    trap "log_warn "Interrupted by user"; rollback" INT TERM
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Run command with error handling
run_command() {
    local cmd="$*"
    log_debug "Running command: $cmd"
    
    if eval "$cmd"; then
        log_debug "Command succeeded: $cmd"
        return 0
    else
        log_error "Command failed: $cmd"
        return 1
    fi
}

echo "Error handler utilities loaded successfully"